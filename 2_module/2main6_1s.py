#2main6_1s.py
#Многопоточность - это спец. функционал,кот позволяет выполнять код пар-но друг другу

import time #пригодится,чтобы затормаживать прогу
import threading #библиотека позволяющая работать с многопоточностью

def sleepTime(wait,name): # принимает 2 пар-ра(выводит текст,потом засыпает на время,и дальше
#выводит какой-то текст)
    print("Выводим текст: {} {}".format(name,wait)) #первая пер-ая уст-тся в 1е скобки,2я во 2е
    time.sleep(wait) #обращаемся к модулю time,а затем ф-ции к sleep()(позволяет остановить прогу
#на несколько секунд)
    print("Выводим текст повторно: {}".format(name))


# td = threading.Thread(target=sleepTime,name='SleepTime',args=(3,'SleepTime')) #обращаемся к threadind создаем новый поток .Thread().
# #В нее предаем несколько пар-ров: target= и в нее надо передать какая ф-ия будет служить для потока-sleepTime.
# #Дальше имя для потока (name='SleepTime').3й пар-тр - различные аргументы args=(3 сек,'SleepTime'- имя пер-ой)

# td.start() #поток не является запущеным,пока не прописали пер-ую,и не добавили .start() 


#чтобы убедиться,что код идет па-но,коментим td и td.start() и прописываем:
# sleepTime(3,'SleepTime') #проверка на многопоточность


#Всегда запущен 1 осн. поток(наша прога).И можем дополнительно запустить еще 1 поток.

# td = threading.Thread(target=sleepTime,name='SleepTime',args=(3,'SleepTime'))
# td.start()
# td.join() # ф-ция кот. говорит,что сначало должен завершиться не основной поток td = threading.Thread.потом запуск осн.потока
# print("Привет всем")


start = time.time() #измеряем время перед запуском
t_list = []

#теперь создаем список(цикл)
# for i in range(5): #это мы создали 5 потоков
#     #здесь надо прописать,что мы передаем разные названия(name=),разное значение(args).Поэтому создаем переменную
    
#     name = 'SleepTime: ' + str(i+1) #чтобы не было ошибки надо приводить i к str
#     print("{} был запущен".format(name))
#     td = threading.Thread(target=sleepTime,name=name,args=(3,name)) # добавили name=name и args(,name)
#     td.start()
#     t_list.append(td)
    
# for t in t_list: #создали перебор в t_list
#     t.join() #обращаемся к каждому эл-ту списка и говорим,что они должны выполняться пар-но не осн. потоку

#если закоментим верхний перебор потоков,и вызовем ф-ию 5 раз,то код будет обрабатываться не 3 сек,а 15 сек

for i in range(5): #тестим 15сек.
    sleepTime(3,i)


end = time.time() #измеряем время после запуска

#чтобы все выполнилось корректно,нужно указать,что сначало выполнятся все доп. потоки,затем все перейдет к осн. потоку(тоесть добавить
#ф-ию .join()).Чтобы это сделать надо указать отдельный список t_list,кот будет содержать все потоки,кот. будем запускать

print("Время обработки: ", (end-start)) #(end-start) - получаем время за кот. у наc были обработаны все потоки
